MMU, CACHE, CP15

MMU简介

 嵌入式系统中，存储系统差别很大，可包含多种类型的存储器件，如FLASH，SRAM，SDRAM，ROM等，这些不同类型的存储器件速度和宽度等各不相同；在访问存储单元时，可能采取平板式的地址映射机制对其操作，或需要使用虚拟地址对其进行读写；系统中，需引入存储保护机制，增强系统的安全性。为适应如此复杂的存储体系要求，ARM处理器中引入了存储管理单元来管理存储系统。



在ARM存储系统中，使用MMU实现虚拟地址到实际物理地址的映射。为何要实现这种映射？首先就要从一个嵌入式系统的基本构成和运行方式着手。系统上电时，处理器的程序指针从0x0（或者是由0Xffff_0000处高端启动）处启动，顺序执行程序，在程序指针（PC）启动地址，属于非易失性存储器空间范围，如ROM、FLASH等。然而与上百兆的嵌入式处理器相比，FLASH、ROM等存储器响应速度慢，已成为提高系统性能的一个瓶颈。而SDRAM具有很高的响应速度，为何不使用SDRAM来执行程序呢？为了提高系统整体速度，可以这样设想，利用FLASH、ROM对系统进行配置，把真正的应用程序下载到SDRAM中运行，这样就可以提高系统的性能。然而这种想法又遇到了另外一个问题，当ARM处理器响应异常事件时，程序指针将要跳转到一个确定的位置，假设发生了IRQ中断，PC将指向0x18(如果为高端启动，则相应指向0vxffff_0018处)，而此时0x18处仍为非易失性存储器所占据的位置，则程序的执行还是有一部分要在FLASH或者ROM中来执行的。那么我们可不可以使程序完全都SDRAM中运行那？答案是肯定的，这就引入了MMU，利用MMU，可把SDRAM的地址完全映射到0x0起始的一片连续地址空间，而把原来占据这片空间的FLASH或者ROM映射到其它不相冲突的存储空间位置。例如，FLASH的地址从0x0000_0000－0x00ff_ffff,而SDRAM的地址范围是0x3000_0000－0x31ff_ffff，则可把SDRAM地址映射为0x0000_0000－0x1fff_ffff而FLASH的地址可以映射到0x9000_0000－0x90ff_ffff（此处地址空间为空闲，未被占用）。映射完成后，如果处理器发生异常，假设依然为IRQ中断，PC指针指向0x18处的地址，而这个时候PC实际上是从位于物理地址的0x3000_0018处读取指令。通过MMU的映射，则可实现程序完全运行在SDRAM之中。
在实际的应用中，可能会把两片不连续的物理地址空间分配给SDRAM。而在操作系统中，习惯于把SDRAM的空间连续起来，方便内存管理，且应用程序申请大块的内存时，操作系统内核也可方便地分配。通过MMU可实现不连续的物理地址空间映射为连续的虚拟地址空间。
操作系统内核或者一些比较关键的代码，一般是不希望被用户应用程序所访问的。通过MMU可以控制地址空间的访问权限，从而保护这些代码不被破坏。
MMU的实现过程，实际上就是一个查表映射的过程。建立页表（translate table）是实现MMU功能不可缺少的一步。页表是位于系统的内存中，页表的每一项对应于一个虚拟地址到物理地址的映射。每一项的长度即是一个字的长度（在ARM中，一个字的长度被定义为4字节）。页表项除完成虚拟地址到物理地址的映射功能之外，还定义了访问权限和缓冲特性等。
MMU的映射分为两种，一级页表的变换和二级页表变换。两者的不同之处就是所实现的变换地址空间大小不同。一级页表变换支持1M大小的存储空间的映射，而二级可以支持64KB、4KB和1KB大小地址空间的映射。
要实现从虚拟地址到物理地址的映射，必然会遇到一个问题，如何找到这个页表。对于表的查找，要知道这个表的基地址和偏移地址，在具有MMU功能的处理器中，集成了一个被称为CP15的协处理器，该协处理器的C2寄存器中用于保存页表的基地址，下面以一级页表变换为例说明MMU实现地址变换的过程。

查找到页表项后，根据页表项的访问特性（缓冲以及是否允许访问等）协处理器决定是否允许访问。如不允许访问，则协处理器向CPU报告出错信息；反之，由页表项的[31：20]位与虚拟地址的[19：0]一起组成实际的物理地址，实现从虚拟地址到物理地址的映射。

对于实际编程工作而言，主要是确定如何编写页表中的内容并如何确定页表项地址。现举例如下：
假设物理地址为0x36B0_0000~0x36Bf_ffff（1M空间）的一块连续空间需映射为0x0100_0000~0x010f_ffff的一块连续空间：
1．确定页表项中的内容：把物理地址的基地址作为页表项的高12位（31bit～21bit），填写访问属性。假设可以读写，可以读缓存、写缓冲，这样该页表项内容为0x36B0_0C00E；
2．确定页表基地址，填写页表基地址到CP15寄存器的C2中。页表的基地址要为64KB对齐；
3．计算出偏移地址，把内容填写到页表项地址中。页表项地址=页表基地址+（物理地址基地址>>18）,如页表基地址为0xA100_0000,那么，页表项地址=0xA100_0DAC；
4．将页表项数值写到对应的页表项地址中。上例中，需要向地址0xA100_0DAC中写入0x36B0_0C00E。


MMU与Cache

Cache是高性能CPU解决总线访问速度瓶颈的方法，然而它的使用却是需要权衡的，因为缓存本身的动作，如块拷贝和替换等，也是很消耗CPU时间的。MMU的重要性勿庸置疑，ARM920T（和ARM720T）集成了MMU是其最大的卖点；有了MMU，高级的操作系统（虚拟地址空间，平面地址，进程保护等）才得以实现。二者都挺复杂，并且在920T中又高度耦合，相互配合操作，所以需要结合起来研究。同时，二者的操作对象都是内存，内存的使用是使用MMU/Cache的关键。另外，MMU和Cache的控制寄存器不占用地址空间，CP15是操纵MMU/Cache的唯一途径。

Cache/Write Buffer的功能

Cache通过预测CPU即将要访问的内存地址（一般都是顺序的），预先读取大块内存供CPU访问，来减少后续的内存总线上的读写操作，以提高速度。然而，如果程序中长跳转的次数很多，Cache的命中率就会显著降低，随之而来，大量的替换操作发生，于是，过多的内存操作反而降低了程序的性能。

ARM内部采用哈佛结构，将内部指令总线和数据总线分开，分别连接到ICache和DCache，再通过AMBA总线接口连接到ASB总线上去访问内存。Cache由Line组成，Line是Cache进行块读取和替换的单位。

Writer Buffer是和DCache相逆过程的一块硬件，目的也是通过减少memory bus的访问来提高性能。

MMU的功能

在内存中维护一张或几张表，就看你怎么给内存划分page和section了。通过CP15指定好转换表的位置，920T的硬件会自动将转换表的一部分读到TLB中。CPU每次进行内存读写时，发出虚拟地址，参照TLB中的转换表转换到物理地址，并读取相应entry中的信息，以决定是否可以有权限读写和缓存。

mmugen这个工具就是帮你构造这个表的，省的自己写程序了。

操作MMU，实际上就是如何分配和使用你的内存，并记录在translationtable里。

ARM中MMU的每条entry包括Cachable和Buffable位来指定相应的内存是否可以用Cache缓存。此处就是MMU与Cache的交互作用处。


实际上，MMU和Cache的使用是操作系统设计者根据系统软硬件配置而考虑的事情。操作系统针对分配给应用程序的地址空间作内存保护和缓存优化。在没有操作系统的情况下，就需要我们自己来掌控它们了。其中，主要是合理分配内存。





AMBA总线

AMBA规范主要包括了AHB(Advanced High performance Bus)系统总线和APB(Advanced Peripheral Bus)外围总线。

AHB简介
AHB主要用于高性能模块(如CPU、DMA和DSP等)之间的连接，作为SoC的片上系统总线，它包括以下一些特性：单个时钟边沿操作；非三态的实现方式；支持突发传输；支持分段传输；支持多个主控制器；可配置32位~128位总线宽度；支持字节、半字节和字的传输。AHB?系统由主模块、从模块和基础结构(Infrastructure)3部分组成，整个AHB总线上的传输都由主模块发出，由从模块负责回应。基础结构则由仲裁器(arbiter)、主模块到从模块的多路器、从模块到主模块的多路器、译码器(decoder)、虚拟从模块(dummy Slave)、虚拟主模块(dummy Master)所组成。

APB简介
APB主要用于低带宽的周边外设之间的连接，例如UART、1284等，它的总线架构不像AHB支持多个主模块，在APB里面唯一的主模块就是APB?桥。其特性包括：两个时钟周期传输；无需等待周期和回应信号；控制逻辑简单，只有四个控制信号。

大多数挂在总线上的模块(包括处理器)只是单一属性的功能模块：主模块或者从模块。主模块是向从模块发出读写操作的模块，如CPU，DSP等；从模块是接受命令并做出反应的模块，如片上的RAM，AHB／APB?桥等。另外，还有一些模块同时具有两种属性，例如直接存储器存取(DMA)在被编程时是从模块，但在系统读传输数据时必须是主模块。如果总线上存在多个主模块，就需要仲裁器来决定如何控制各种主模块对总线的访问。虽然仲裁规范是AMBA总线规范中的一部分，但具体使用的算法由RTL设计工程师决定，其中两个最常用的算法是固定优先级算法和循环制算法。AHB总线上最多可以有16个主模块和任意多个从模块，如果主模块数目大于16，则需再加一层结构(具体参阅ARM公司推出的Multi-layer AHB规范)。APB?桥既是APB总线上唯一的主模块，也是AHB系统总线上的从模块。其主要功能是锁存来自AHB系统总线的地址、数据和控制信号，并提供二级译码以产生APB外围设备的选择信号，从而实现AHB协议到APB协议的转换。


nand flash：适合大容量数据存储，类似硬盘；
nor flash：适合小容量的程序或数据存储，类似小硬盘；
sdram：主要用于程序执行时的程序存储、执行或计算，类似内存。

区别：
nor flash：可以直接执行指令，读取速度较快，写入不太方便，擦除速度较慢。
nand flash：读取速度比nor flash略快，但写入、擦除都较快。但可靠性略低，需要做损耗平衡、数据校验等。
因此：nor适合做程序存储，nand适合做大容量数据存储。二者都可以掉电保存数据/程序。

sdram：掉电后数据不保存，运行时需要动态刷新，但读取速度都比flash快，适合启动后的程序执行。使用前需要初始化。

nor flash与nand flash的一些区别

1)接口区别：
NOR FLASH地址线和数据线分开，来了地址和控制信号，数据就出来。
NAND Flash地址线和数据线在一起，需要用程序来控制，才能出数据。
通俗的说，就是光给地址不行，要先命令，再给地址，才能读到NAND的数据。而且都是在一个总线完成的。
结论是：ARM无法从NAND直接启动。除非装载完程序，才能使用NAND Flash.
2)性能区别
NOR的传输效率很高，在1～4MB的小容量时具有很高的成本效益，但是很低的写入和擦除速度大大影响了它的性能。 NAND结构能提供极高的单元密度，可以达到高存储密度，并且写入和擦除的速度也很快。应用NAND的困难在于flash的管理和需要特殊的系统接口。
● NOR的读速度比NAND稍快一些。
● NAND的写入速度比NOR快很多。
● NAND的4ms擦除速度远比NOR的5s快。
● 大多数写入操作需要先进行擦除操作。
● NAND的擦除单元更小，相应的擦除电路更少。

===========================================

ARM的nor flash与nand flash启动过程区别

B，s3c2440启动过程详解
1:地址空间的分配
2:开发板上一般都用SDRAM做内存flash（nor、nand）来当做ROM。其中nand flash没有地址线，一次至少要读一页(512B).其他两个有地址线
3:nandflash不用来运行代码，只用来存储代码，NORflash，SDRAM可以直接运行代码）
4:s3c2440总共有8个内存banks
  6个内存bank可以当作ROM或者SRAM来使用
  留下的2个bank除了当作ROM 或者SRAM，还可以用SDRAM(各种内存的读写方式不一样)
  7个bank的起始地址是固定的
  还有一个灵活的bank的内存地址，并且bank大小也可以改变
5:s3c2440支持两种启动模式：NAND和非NAND（这里是nor flash）。
具体采用的方式取决于OM0、OM1两个引脚
OM[1:0所决定的启动方式
OM[1：0]=00时，处理器从NAND Flash启动
OM[1：0]=01时，处理器从16位宽度的ROM启动
OM[1：0]=10时，处理器从32位宽度的ROM启动。
OM[1：0]=11时，处理器从Test Mode启动。

当从NAND启动时

    cpu会自动从NAND flash中读取前4KB的数据放置在片内SRAM里（s3c2440是soc），同时把这段片内SRAM映射到nGCS0片选的空间（即0x00000000）。cpu是从0x00000000开始执行，也就是NAND flash里的前4KB内容。因为NAND FLASH连地址线都没有，不能直接把NAND映射到0x00000000，只好使用片内SRAM做一个载体。通过这个载体把nandflash中大代码复制到RAM(一般是SDRAM)中去执行


当从非NAND flash启动时

    nor flash被映射到0x00000000地址（就是nGCS0，这里就不需要片内SRAM来辅助了，所以片内SRAM的起始地址还是0x40000000）. 然后cpu从0x00000000开始执行（也就是在Norfalsh中执行）。


Clock&power management 

模块包含 Clock控制、、POWER控制.       

     时钟控制逻辑单元能够产生2440需要的时钟信号，包括CPU使用的主频FCLK,AHB总线设备使用的HCLK,以及APB总线设备使用的PCLK.2440内部有2个PLL(锁相环)：一个MPLL对应FCLK,HCLK,PCLK；另外一个UPLL对应的是USB使用(48MHz)。.时钟控制逻辑单元可以在不使用PLL情况下降低时钟CLOCK的频率，并且可以通过软件来驱使时钟和各个模块的连接/切断，这样做可以减少电源消耗。

     [S3C2440 CPU默认的工作主频为12MHz，使用PLL电路可以产生更高的主频供CPU及外围器件使用。S3C2410有两个PLL：MPLL和UPLL，UPLL专用与USB设备。MPLL用于CPU及其他外围器件。通过MPLL会产生三个部分的时钟频率：FCLK、HCLK、PLCK。FCLK用于CPU核，HCLK用于AHB总线的设备(比如SDRAM)，PCLK用于APB总线的设备(比如UART)。从时钟结构图中可以查看到使用不同时钟频率的硬件。]

     对于电源控制逻辑单元，2440有许多钟电源管理方法来针对不用任务保持相应的电源消耗。电源管理模块包含了4种方式：NORMAL、SLOW,IDLE,SLEEP。

     NORMAL:这个模块支持CPU时钟以及2440相应的外围设备时钟。这个模式下，电源消耗是最大的。它允许通过软件编程来控制外部设备的操作。例如，如果一个定时器Timer不需要时，那么用户可以通过CLKCON寄存器来关闭时钟和Timer相连，来降低电源消耗。

     SLOW模式：又叫NON-PLL模式，不同于Normal模式，这个模式使用的时一个外部时钟来直接驱动2440的主频FCLK，不通过PLL,在这个模式下，电源的消耗仅仅和外部时钟频率有关，电源同PLL有关的消耗可以忽略。

     IDLE模式：这个模式下CPU的时钟FCLK被关闭，而其他外围设备的时钟还继续工作。因此空闲模式的结果只是能够降低CPU核的电源消耗。注意，任何中断请求都能够将CPU唤醒。

     Sleep模式：这个模式关闭了内部电源。因此CPU＆内部的逻辑单元都没有电源消耗，除了工作在这个模式下的一个wake-up逻辑单元。因此sleep模式需要2个独立的电源。一个来支持wake-up模块工作，另外一个支持内部逻辑＆CPU的电源，并且这个模块的电源是可控的。所以在Sleep模式，支持内部逻辑＆CPU的电源模块是关闭的，而通过EINT[15:0]＆RTC中断可以从Sleep模式唤醒。



GPIO

用户可以通过GPIO口和硬件进行数据交互(如UART)，控制硬件工作(如LED、蜂鸣器等),读取硬件的工作状态信号（如中断信号）等。GPIO口的使用非常广泛。
I/O Ports大部分是复用的，通常可以用作为输入口(input)、输出口(output)以及特殊功能口(如中断信号)。通过相应口的配置寄存器(GPxCON)可以选择配置为不同的功能。配置好GPIO口的功能后就可以在相应数据寄存器GPxDAT读/写数据，GPxUP用于确定是否使用内部上拉电阻。

ARM9--s3c2440的GPIO是这样的:

GPA,GPB,GPC......GPJ一共9组,比2410多了一组

GPIO是用来进行输入输出的,有寄存器进行控制

对于输入的话,我们一定可以通过读取寄存器来确定引脚的高电平还是低电平;

对于输出的话,我们一定也可以通过写某个寄存器来让这个引脚输出高低电平.


1控制类的:

GPxCON

portA有点与众不同啊,GPACON每一位对应着一根引脚(23根)

0:代表输出;1:相应的引脚为地址线或用于地址控制

对于PORT B-PORT J的话,GPxCON中每两位控制一根引脚

00:输入;01:输出;10:特殊功能;11:保留
2.数据

GPxDAT

用于读或者写
3.GPxUP

1:不使用内部的上拉电阻;0:使用内部上拉电阻
（注：上拉电阻作用为当I/O PORTS被定义为input口时，为了避免信号干扰产生不正确的值，通常会使用上拉电阻。）


UART
串口通信的基本概念:
1，什么是串口？
2，什么是RS-232？
3，什么是RS-422？
4，什么是RS-485？
5，什么是握手？

1，什么是串口
串口是计算机上一种非常通用设备通信的协议（不要与通用串行总线Universal Serial Bus或者USB混淆）。大多数计算机包含两个基于RS232的串口。串口同时也是仪器仪表设备通用的通信协议；很多GPIB兼容的设备也带有RS-232口。同时，串口通信协议也可以用于获取远程采集设备的数据。

串口通信的概念非常简单，串口按位（bit）发送和接收字节。尽管比按字节（byte）的并行通信慢，但是串口可以在使用一根线发送数据的同时用另一根线接收数据。它很简单并且能够实现远距离通信。比如IEEE488定义并行通行状态时，规定设备线总常不得超过20米，并且任意两个设备间的长度不得超过2米；而对于串口而言，长度可达1200米。

典型地，串口用于ASCII码字符的传输。通信使用3根线完成：（1）地线，（2）发送，（3）接收。由于串口通信是异步的，端口能够在一根线上发送数据同时在另一根线上接收数据。其他线用于握手，但是不是必须的。串口通信最重要的参数是波特率、数据位、停止位和奇偶校验。对于两个进行通行的端口，这些参数必须匹配：

a，波特率：这是一个衡量通信速度的参数。它表示每秒钟传送的bit的个数。例如300波特表示每秒钟发送300个bit。当我们提到时钟周期时，我们就是指波特率例如如果协议需要4800波特率，那么时钟是4800Hz。这意味着串口通信在数据线上的采样率为4800Hz。通常电话线的波特率为14400，28800和36600。波特率可以远远大于这些值，但是波特率和距离成反比。高波特率常常用于放置的很近的仪器间的通信，典型的例子就是GPIB设备的通信。

b，数据位：这是衡量通信中实际数据位的参数。当计算机发送一个信息包，实际的数据不会是8位的，标准的值是5、7和8位。如何设置取决于你想传送的信息。比如，标准的ASCII码是0～127（7位）。扩展的ASCII码是0～255（8位）。如果数据使用简单的文本（标准 ASCII码），那么每个数据包使用7位数据。每个包是指一个字节，包括开始/停止位，数据位和奇偶校验位。由于实际数据位取决于通信协议的选取，术语“包”指任何通信的情况。

c，停止位：用于表示单个包的最后一位。典型的值为1，1.5和2位。由于数据是在传输线上定时的，并且每一个设备有其自己的时钟，很可能在通信中两台设备间出现了小小的不同步。因此停止位不仅仅是表示传输的结束，并且提供计算机校正时钟同步的机会。适用于停止位的位数越多，不同时钟同步的容忍程度越大，但是数据传输率同时也越慢。

d，奇偶校验位：在串口通信中一种简单的检错方式。有四种检错方式：偶、奇、高和低。当然没有校验位也是可以的。对于偶和奇校验的情况，串口会设置校验位（数据位后面的一位），用一个值确保传输的数据有偶个或者奇个逻辑高位。例如，如果数据是011，那么对于偶校验，校验位为0，保证逻辑高的位数是偶数个。如果是奇校验，校验位位1，这样就有3个逻辑高位。高位和低位不真正的检查数据，简单置位逻辑高或者逻辑低校验。这样使得接收设备能够知道一个位的状态，有机会判断是否有噪声干扰了通信或者是否传输和接收数据是否不同步。

2，什么是RS-232？
RS-232（ANSI/EIA-232标准）是IBM-PC及其兼容机上的串行连接标准。可用于许多用途，比如连接鼠标、打印机或者Modem，同时也可以接工业仪器仪表。用于驱动和连线的改进，实际应用中RS-232的传输长度或者速度常常超过标准的值。RS-232只限于PC串口和设备间点对点的通信。RS-232串口通信最远距离是50英尺。


\ 1 2 3 4 5 /
 \ 6 7 8 9 /
     -------
从计算机连出的线的截面。
RS-232针脚的功能：

数据：
TXD（pin 3）：串口数据输出
RXD（pin 2）：串口数据输入

握手：
RTS（pin 7）：发送数据请求
CTS（pin 8）：清除发送
DSR（pin 6）：数据发送就绪
DCD（pin 1）：数据载波检测
DTR（pin 4）：数据终端就绪

地线：
GND（pin 5）：地线

其他
RI（pin 9）：铃声指示

3，什么是RS-422？
RS-422（EIA RS-422-A Standard）是Apple的Macintosh计算机的串口连接标准。RS-422使用差分信号，RS-232使用非平衡参考地的信号。差分传输使用两根线发送和接收信号，对比RS-232，它能更好的抗噪声和有更远的传输距离。在工业环境中更好的抗噪性和更远的传输距离是一个很大的优点。

4，什么是RS-485？
RS-485（EIA-485标准）是RS-422的改进，因为它增加了设备的个数，从10个增加到32个，同时定义了在最大设备个数情况下的电气特性，以保证足够的信号电压。有了多个设备的能力，你可以使用一个单个RS-422口建立设备网络。出色抗噪和多设备能力，在工业应用中建立连向PC机的分布式设备网络、其他数据收集控制器、HMI或者其他操作时，串行连接会选择RS-485。RS-485是RS-422的超集，因此所有的RS-422设备可以被RS-485控制。RS-485可以用超过4000英尺的线进行串行通行。

DB-9 引脚连接

 -------------
\ 1 2 3 4 5 /
 \ 6 7 8 9 /
     -------

从计算机连出的线的截面。

RS-485和RS-422的引脚的功能
数据：TXD+（pin 8），TXD-（pin 9），RXD+（pin 4），RXD-（pin 5）
握手：RTS+（pin 3），RTS-（pin 7），CTS+（pin 2），CTS-（pin 6）
地线：GND （pin 1）

5，什么是握手？
RS-232通行方式允许简单连接三线：Tx、Rx和地线。但是对于数据传输，双方必须对数据定时采用使用相同的波特率。尽管这种方法对于大多数应用已经足够，但是对于接收方过载的情况这种使用受到限制。这时需要串口的握手功能。在这一部分，我们讨论三种最常用的RS-232握手形式：软件握手、硬件握手和Xmodem。

a，软件握手：我们讨论的第一种握手是软件握手。通常用在实际数据是控制字符的情况，类似于GPIB使用命令字符串的方式。必须的线仍然是三根：Tx，Rx和地线，因为控制字符在传输线上和普通字符没有区别，函数SetXModem允许用户使能或者禁止用户使用两个控制字符XON和OXFF。这些字符在通信中由接收方发送，使发送方暂停。
例如：假设发送方以高波特率发送数据。在传输中，接收方发现由于CPU忙于其他工作，输入buffer已经满了。为了暂时停止传输，接收方发送XOFF，典型的值是十进制19，即十六进制13，直到输入buffer空了。一旦接收方准备好接收，它发送XON，典型的值是十进制17，即十六进制11，继续通信。输入buffer半满时，LabWindows发送XOFF。此外，如果XOFF传输被打断，LabWindows会在buffer达到75％和90％时发送XOFF。显然，发送方必须遵循此守则以保证传输继续。

b，硬件握手：第二种是使用硬件线握手。和Tx和Rx线一样，RTS/CTS和DTR/DSR一起工作，一个作为输出，另一个作为输入。第一组线是RTS（Request to Send）和CTS（Clear to Send）。当接收方准备好接收数据，它置高RTS线表示它准备好了，如果发送方也就绪，它置高CTS，表示它即将发送数据。另一组线是DTR（Data Terminal Ready）和DSR（Data Set Ready）。这些现主要用于Modem通信。使得串口和Modem通信他们的状态。例如：当Modem已经准备好接收来自PC的数据，它置高DTR线，表示和电话线的连接已经建立。读取DSR线置高，PC机开始发送数据。一个简单的规则是DTR/DSR用于表示系统通信就绪，而RTS/CTS用于单个数据包的传输。

在LabWindows，函数SetCTSMode使能或者禁止使用硬件握手。如果CTS模式使能，LabWindows使用如下规则：
当PC发送数据：
RS-232库必须检测CTS线高后才能发送数据。

当PC接收数据：
如果端口打开，且输入队列有空接收数据，库函数置高RTS和DTR。
如果输入队列90％满，库函数置低RTS，但使DTR维持高电平。
如果端口队列近乎空了，哭喊数置高RTS，但使DRT维持高电平。
如果端口关闭，库函数置低RTS和DTR。

c，XModem握手：最后讨论的握手叫做XModem文件传输协议。这个协议在Modem通信中非常通用。尽管它通常使用在Modem通信中，XModem协议能够直接在其他遵循这个协议的设备通信中使用。在LabWindows中，实际的XModem应用对用户隐藏了。只要PC和其他设备使用XModem协议，在文件传输中就使用LabWindows的XModem函数。函数是XModemConfig，XModemSend和XModemReceive。

XModem使用介于如下参数的协议：start_of_data、end_of_data、neg_ack、wait_delay、start_delay、max_tries、packet_size。这些参数需要通信双方认定，标准的XModem有一个标准的定义：然而，可以通过XModemConfig函数修改，以满足具体需要。这些参数的使用方法由接收方发送的字符neg_ack确定。这通知发送方其准备接收数据。它开始尝试发送，有一个超时参数start_delay；当超时的尝试超过max_ties次数，或者收到接收方发送的start_of_data，发送方停止尝试。如果从发送方收到start_of_data，接收方将读取后继信息数据包。包中含有包的数目、包数目的补码作为错误校验、packet_size字节大小的实际数据包，和进一步错误检查的求和校验值。在读取数据后，接收方会调用wait_delay，然后想发送方发送响应。如果发送方没有收到响应，它会重新发送数据包，直到收到响应或者超过重发次数的最大值max_tries。如果一直没有收到响应，发送方通知用户传输数据失败。由于数据必须以pack_size个字节按包发送，当最后一个数据包发送时，如果数据不够放满一个数据包，后面会填充ASCII码NULL（0）字节。这导致接收的数据比原数据多。在XModem情况下一定不要使用XON/XOFF，因为XModem发送方发出包的数目很可能增加到XON/OFF控制字符的值，从而导致通信故障。

TIMER
定时器的时钟源是PCLK，工作流程如下：

1.定时器内部的预分频器对定时器时钟源进行分频；

2.分频后，输出的时钟才是定时器内部的计数器时钟源；因此预分频器起着转换时钟频率的作用；

3.计数值与匹配寄存器不断的比较，当两者相等时，发生匹配事件，然后执行相应的操作--产生中断，匹配输出引脚（MAT）输出指定信号等等；

4.当捕获引脚出现有效边沿时，定时器会将当前的计数值保存到捕获寄存器中，同时也可以产生中断。

 

因此我们可以看到，ARM中的定时器主要由三部分构成：计数器部分，匹配功能部分，捕获功能部分。所以寄存器也相应分成了基本寄存器组，匹配功能寄存器组和捕获功能寄存器组。

基本寄存器组主要针对基本计数器功能，包括中断标志寄存器IR，定时器控制寄存器TCR，定时器计数器TC，预分频寄存器PR，和预分频计数器PC。

匹配寄存器组主要针对定时器的匹配功能，包括：匹配寄存器MR0-3，匹配控制寄存器MCR和外部匹配寄存器EMR。

捕获功能寄存器组针对定时器的捕获功能，包括：捕获寄存器和捕获控制寄存器。其中捕获寄存器用来设置捕获信号，发生捕获事件时，定时器的计数值保存到捕获寄存器中。



DMA
DMA原理：DMA(Direct Memory Access，直接内存存取) 允许不同速度的硬件装置来沟通，而不需要依于 CPU 的大量 中断 负载。否则，CPU 需要从 来源 把每一片段的资料复制到 暂存器，然后把他们再次写回到新的地方。
在这个时间中，CPU 对于其他的工作来说就无法使用。 DMA 传输重要地将一个内存区从一个装置复制到另外一个。

当 CPU 初始化这个传输动作，传输动作本身是由 DMA 控制器 来实行和完成。
典型的例子就是移动一个外部内存的区块到芯片内部更快的内存区。像是这样的操作并没有让处理器工作拖延，反而可以被重新排程去处理其他的工作。
DMA 传输对于高效能 嵌入式系统 算法是很重要的。　 　　
在实现DMA传输时，是由DMA控制器直接掌管总线，因此，存在着一个总线控制权转移问题。即DMA传输前，CPU要把总线控制权交给DMA控制器，而在结束DMA传输后，DMA控制器应立即把总线控制权再交回给CPU。
一个完整的DMA传输过程必须经过下面的4个步骤。
1.DMA请求
　　CPU对DMA控制器初始化，并向I/O接口发出操作命令，I/O接口提出DMA请求。

2.DMA响应
　　DMA控制器对DMA请求判别优先级及屏蔽，向总线裁决逻辑提出总线请求。当CPU执行完当前总线周期即可释放总线控制权。此时，总线裁决逻辑输出总线应答，表示DMA已经响应，通过DMA控制器通知I/O接口开始DMA传输。

3.DMA传输
　　DMA控制器获得总线控制权后，CPU即刻挂起或只执行内部操作，由DMA控制器输出读写命令，直接控制RAM与I/O接口进行DMA传输。 　　在DMA控制器的控制下，在存储器和外部设备之间直接进行数据传送，在传送过中不需要中央处理器的参与。开始时需提供要传送的数据的起始位置和数据长度。

4.DMA结束
　　当完成规定的成批数据传送后，DMA控制器即释放总线控制权，并向I/O接口发出结束信号。当I/O接口收到结束信号后，一方面停 止I/O设备的工作，另一方面向CPU提出中断请求，使CPU从不介入的状态解脱，并执行一段检查本次DMA传输操作正确性的代码。最后，带着本次操作结果及状态继续执行原来的程序。 　　

由此可见，DMA传输方式无需CPU直接控制传输，也没有中断处理方式那样保留现场和恢复现场的过程，通过硬件为RAM与I/O设备开辟一条直接传送数据的通路，使CPU的效率大为提高。

DMA请求源：通过设置DCON[23]位SWHW_SEL值，选择硬/软件请求，并可进一步通过设置HWSRCSEL[26:24]位选择HW模式下的每个DMA通道的请求源

DMA工作过程：使用三态FSM（有限状态机）进行操作，分三步操作：

Stage-1 初始状态，等待DMA请求，若请求到达，进入Stage-2。此阶段，DMA ACK和INT REQ都为0。

Stage-2 DMA ACK变为1，计数器CURR_TC从DCON[19:0]加载数值。注意：此时DMA ACK仍然为1，知道它随后在stage-3中被清0。

Stage-3 在此状态，对DMA进行原子操作的sub-FSM（子状态机）被初始化它从源地址读取数据然后写入目的地址（此操作需要考虑数据大小和传输尺寸）。

每一次DMA传输，必须先得到请求。

有两种请求模式：Demand和Handshake。差别在于是否等待DREQ信号无效：

Handshake模式下，DMA控制器在开始下一次传输之前要一直等待直到DREQ信号无效。如果DREQ信号无效了，DMA 控制器使DACK无效后继续等待下一次DREQ信号有效，之后又开始数据传输，且使DACK信号有效。

Demand模式下，DMA控制器不等待DREQ信号无效。如果传输完毕后DREQ还是继续有效，DMA控制器只是先无效DACK信号，然后又开始新一轮的传输。数据手册上建议对外部DMA请求使用Handshake模式，以避免不经意的开始新一轮数据传输。


2.1、SPI：高速同步串行口
　　SPI：高速同步串行口。是一种标准的四线同步双向串行总线。 　　SPI，是英语Serial Peripheral interface的缩写，顾名思义就是串行外围设备接口。是Motorola首先在其MC68HCXX系列处理器上定义的。SPI接口主要应用在 EEPROM，FLASH，实时时钟，AD转换器，还有数字信号处理器和数字信号解码器之间。SPI，是一种高速的，全双工，同步的通信总线，并且在芯片的管脚上只占用四根线，节约了芯片的管脚，同时为PCB的布局上节省空间，提供方便，正是出于这种简单易用的特性，现在越来越多的芯片集成了这种通信协议，比如AT91RM9200. 　　SPI总线系统是一种同步串行外设接口，它可以使MCU与各种外围设备以串行方式进行通信以交换信息。外围设置FLASHRAM、网络控制器、LCD显示驱动器、A/D转换器和MCU等。SPI总线系统可直接与各个厂家生产的多种标准外围器件直接接口，该接口一般使用4条线：串行时钟线（SCLK）、主机输入/从机输出数据线MISO、主机输出/从机输入数据线MOSI和低电平有效的从机选择线SS(有的SPI接口芯片带有中断信号线INT、有的SPI接口芯片没有主机输出/从机输入数据线MOSI)。 　　SPI的通信原理很简单，它以主从方式工作，这种模式通常有一个主设备和一个或多个从设备，需要至少4根线，事实上3根也可以（用于单向传输时，也就是半双工方式）。也是所有基于SPI的设备共有的，它们是SDI（数据输入），SDO（数据输出），SCLK（时钟），CS（片选）。 　　（1）MOSI C SPI 总线主机输出/ 从机输入（SPI Bus Master Output/Slave Input） 　　（2）MISO C SPI 总线主机输入/ 从机输出（SPI Bus Master Input/Slave Output) 　　（3）SCLK C 时钟信号，由主设备产生 　　（4）CS C 从设备使能信号，由主设备控制 　　其中CS是控制芯片是否被选中的，也就是说只有片选信号为预先规定的使能信号时（高电位或低电位），对此芯片的操作才有效。这就允许在同一总线上连接多个SPI设备成为可能。 　　接下来就负责通讯的3根线了。通讯是通过数据交换完成的，这里先要知道SPI是串行通讯协议，也就是说数据是一位一位的传输的。这就是SCLK时钟线存在的原因，由SCK提供时钟脉冲，SDI，SDO则基于此脉冲完成数据传输。数据输出通过 SDO线，数据在时钟上升沿或下降沿时改变，在紧接着的下降沿或上升沿被读取。完成一位数据传输，输入也使用同样原理。这样，在至少8次时钟信号的改变（上沿和下沿为一次），就可以完成8位数据的传输。 　　要注意的是，SCLK信号线只由主设备控制，从设备不能控制信号线。同样，在一个基于SPI的设备中，至少有一个主控设备。这样传输的特点：这样的传输方式有一个优点，与普通的串行通讯不同，普通的串行通讯一次连续传送至少8位数据，而SPI允许数据一位一位的传送，甚至允许暂停，因为SCLK时钟线由主控设备控制，当没有时钟跳变时，从设备不采集或传送数据。也就是说，主设备通过对SCLK时钟线的控制可以完成对通讯的控制。SPI还是一个数据交换协议：因为SPI的数据输入和输出线独立，所以允许同时完成数据的输入和输出。不同的SPI设备的实现方式不尽相同，主要是数据改变和采集的时间不同，在时钟信号上沿或下沿采集有不同定义，具体请参考相关器件的文档。 　　在点对点的通信中，SPI接口不需要进行寻址操作，且为全双工通信，显得简单高效。在多个从设备的系统中，每个从设备需要独立的使能信号，硬件上比I2C系统要稍微复杂一些。
2.2、接口的硬件连接示意图
　　在多个从器件的系统中,每个从器件需要独立的使能信号,硬件上比I2C系统要稍微复杂一些。 　　SPI接口在内部硬件实际上是两个简单的移位寄存器,传输的数据为8位,在主器件产生的从器件使能信号和移位脉冲下,按位传输,高位在前,低位在后。如下图所示,在SCLK的下降沿上数 　　据改变,同时一位数据被存入移位寄存器。
2.3、性能特点
　　AT91RM9200的SPI接口主要由4个引脚构成：SPICLK、MOSI、MISO及 /SS，其中SPICLK是整个SPI总线的公用时钟，MOSI、MISO作为主机，从机的输入输出的标志，MOSI是主机的输出，从机的输入，MISO 是主机的输入，从机的输出。/SS是从机的标志管脚，在互相通信的两个SPI总线的器件，/SS管脚的电平低的是从机，相反/SS管脚的电平高的是主机。在一个SPI通信系统中，必须有主机。SPI总线可以配置成单主单从，单主多从，互为主从。 　　SPI的片选可以扩充选择16个外设,这时PCS输出=NPCS,说NPCS0~3接4-16译码器,这个译码器是需要外接4-16译码器，译码器的输入为NPCS0~3，输出用于16个外设的选择。 　　SPI接口的一个缺点：没有指定的流控制，没有应答机制确认是否接收到数据。
2.4、SPI协议举例
　　SPI是一个环形总线结构，由ss（cs）、sck、sdi、sdo构成，其时序其实很简单，主要是在sck的控制下，两个双向移位寄存器进行数据交换。 　　假设下面的8位寄存器装的是待发送的数据10101010，上升沿发送、下降沿接收、高位先发送。 　　那么第一个上升沿来的时候 数据将会是sdo=1；寄存器中的10101010左移一位，后面补入送来的一位未知数x，成了0101010x。下降沿到来的时候，sdi上的电平将锁存到寄存器中去，那么这时寄存器=0101010sdi，这样在 8个时钟脉冲以后，两个寄存器的内容互相交换一次。这样就完成了一个spi时序。
2.5、举例
　　假设主机和从机初始化就绪：并且主机的sbuff=0xaa，从机的sbuff=0x55，下面将分步对spi的8个时钟周期的数据情况演示一遍:假设上升沿发送数据 　　脉冲 主机sbuff 从机sbuff sdi sdo 　　0 10101010 01010101 0 0 　　1上 0101010x 1010101x 0 1 　　1下 01010100 10101011 0 1 　　2上 1010100x 0101011x 1 0 　　2下 10101001 01010110 1 0 　　3上 0101001x 1010110x 0 1 　　3下 01010010 10101101 0 1 　　4上 1010010x 0101101x 1 0 　　4下 10100101 01011010 1 0 　　5上 0100101x 1011010x 0 1 　　5下 01001010 10110101 0 1 　　6上 1001010x 0110101x 1 0 　　6下 10010101 01101010 1 0 　　7上 0010101x 1101010x 0 1 　　7下 00101010 11010101 0 1 　　8上 0101010x 1010101x 1 0 　　8下 01010101 10101010 1 0 　　这样就完成了两个寄存器8位的交换，上面的上表示上升沿、下表示下降沿，sdi、sdo相对于主机而言的。其中ss引脚作为主机的时候，从机可以把它拉底被动选为从机，作为从机的是时候，可以作为片选脚用。根据以上分析，一个完整的传送周期是16位，即两个字节，因为，首先主机要发送命令过去，然后从机 　　根据主机的命令准备数据，主机在下一个8位时钟周期才把数据读回来。 SPI 总线是Motorola公司推出的三线同步接口，同步串行3线方式进行通信:一条时钟线SCK，一条数据输入线MISO，一条数据输出线MOSI;用于CPU与各种外围器件进行全双工、同步串行通讯。SPI主要特点有:可以同时发出和接收串行数据;可以当作主 　　机或从机工作;提供频率可编程时钟;发送结束 中断标志;写冲突保护;总线竞争保护等。下图示出SPI总线工作的四种方式，其中使用的最为广泛的是SPI0和SPI3方式 (实线表示): 　　  
SPI总线四种工作方式 SPI 模块为了和外设进行数据交换，根据外设工作要求，其输出串行同步时钟极性和相位可以进行配置，时钟极性（CPOL）对传输协议没有重大的影响。如果 CPOL=0，串行同步时钟的空闲状态为低电平；如果CPOL=1，串行同步时钟的空闲状态为高电平。时钟相位（CPHA）能够配置用于选择两种不同的传输协议之一进行数据传输。如果CPHA=0，在串行同步时钟的第一个跳变沿（上升或下降）数据被采样；如果CPHA=1，在串行同步时钟的第二个跳变沿（上升或下降）数据被采样。SPI主模块和与之通信的外设备时钟相位和极性应该一致。 　　  
SPI总线包括1根串行同步时钟信号线以及2根数据线。 　　SPI模块为了和外设进行数据交换，根据外设工作要求，其输出串行同步时钟极性和相位可以进行配置，时钟极性（CPOL）对传输协议没有重大的影响。如果CPOL=0，串行同步时钟的空闲状态为低电平；如果CPOL=1，串行同步时钟的空闲状态为高电平。时钟相位（CPHA）能够配置用于选择两种不同的传输协议之一进行数据传输。如果CPHA=0，在串行同步时钟的第一个跳变沿（上升或下降）数据被采样；如果CPHA=1，在串行同步时钟的第二个跳变沿（上升或下降）数据被采样。SPI主模块和与之通信的外设音时钟相位和极性应该一致。SPI接口时序如图3、图4所示。
2.6、性能补充
　　上文中最后一句话：SPI主模块和与之通信的外设备时钟相位和极性应该一致。个人理解这句话有2层意思：其一，主设备SPI时钟和极性的配置应该由外设来决定；其二，二者的配置应该保持一致，即主设备的SDO同从设备的SDO配置一致，主设备的SDI同从设备的SDI配置一致。因为主从设备是在SCLK的控制下，同时发送和接收数据，并通过2个双向移位寄存器来交换数据。工作原理演示如下图： 　　上升沿主机SDO发送数据1，同时从设备SDO发送数据0；紧接着在SCLK的下降沿的时候从设备的SDI接收到了主机发送过来的数据1，同时主机也接收到了从设备发送过来的数据0.
2.7、SPI协议心得
　　SPI接口时钟配置心得： 　　在主设备这边配置SPI接口时钟的时候一定要弄清楚从设备的时钟要求，因为主设备这边的时钟极性和相位都是以从设备为基准的。因此在时钟极性的配置上一定要搞清楚从设备是在时钟的上升沿还是下降沿接收数据，是在时钟的下降沿还是上升沿输出数据。但要注意的是，由于主设备的SDO连接从设备的SDI，从设备的SDO连接主设备的SDI，从设备SDI接收的数据是主设备的SDO发送过来的，主设备SDI接收的数据是从设备SDO发送过来的，所以主设备这边SPI时钟极性的配置（即SDO的配置）跟从设备的SDI接收数据的极性是相反的，跟从设备SDO发送数据的极性是相同的。下面这段话是Sychip Wlan8100 Module Spec上说的，充分说明了时钟极性是如何配置的： 　　The 81xx module will always input data bits at the rising edge of the clock, and the host will always output data bits on the falling edge of the clock. 　　意思是：主设备在时钟的下降沿发送数据，从设备在时钟的上升沿接收数据。因此主设备这边SPI时钟极性应该配置为下降沿有效。 　　又如，下面这段话是摘自LCD Driver IC SSD1289： 　　SDI is shifted into 8-bit shift register on every rising edge of SCK in the order of data bit 7, data bit 6 …… data bit 0. 　　意思是：从设备SSD1289在时钟的上升沿接收数据，而且是按照从高位到低位的顺序接收数据的。因此主设备的SPI时钟极性同样应该配置为下降沿有效。 　　时钟极性和相位配置正确后，数据才能够被准确的发送和接收。因此应该对照从设备的SPI接口时序或者Spec文档说明来正确配置主设备的时钟。



I2C
I2C串行总线一般有两根信号线，一根是双向的数据线SDA，另一根是时钟线SCL。所有接到I2C总线设备上的串行数据SDA都接到总线的SDA上，各设备的时钟线SCL接到总线的SCL上。典型的I2C总线结构如图1所示。 　　为了避免总线信号的混乱，要求各设备连接到总线的输出端时必须是漏极开路（OD）输出或集电极开路（OC）输出。设备与总线的接口电路如图2所示。设备上的串行数据线SDA接口电路应该是双向的，输出电路用于向总线上发送数据，输入电路用于接收总线上的数据。而串行时钟线也应是双向的，作为控制总线数据传送的主机，一方面要通过SCL输出电路发送时钟信号，另一方面还要检测总线上的SCL电平，以决定什么时候发送下一个时钟脉冲电平；作为接受主机命令的从机，要按总线上的SCL信号发出或接收SDA上的信号，也可以向SCL线发出低电平信号以延长总线时钟信号周期。总线空闲时，因各设备都是开漏输出，上拉电阻Rp使SDA和SCL线都保持高电平。任一设备输出的低电平都将使相应的总线信号线变低，也就是说：各设备的SDA是“与”关系，SCL也是“与”关系。 　　总线对设备接口电路的制造工艺和电平都没有特殊的要求（NMOS、CMOS都可以兼容）。在I2C总线上的数据传送率可高达每秒十万位，高速方式时在每秒四十万位以上。另外，总线上允许连接的设备数以其电容量不超过400pF为限。 　　总线的运行（数据传输）由主机控制。所谓主机是指启动数据的传送（发出启动信号）、发出时钟信号以及传送结束时发出停止信号的设备，通常主机都是微处理器。被主机寻访的设备称为从机。为了进行通讯，每个接到I2C总线的设备都有一个唯一的地址，以便于主机寻访。主机和从机的数据传送，可以由主机发送数据到从机，也可以由从机发到主机。凡是发送数据到总线的设备称为发送器，从总线上接收数据的设备被称为接受器。 　　I2C总线上允许连接多个微处理器以及各种外围设备，如存储器、LED及LCD驱动器、A/D及D/A转换器等。为了保证数据可靠地传送，任一时刻总线只能由某一台主机控制，各微处理器应该在总线空闲时发送启动数据，为了妥善解决多台微处理器同时发送启动数据的传送（总线控制权）冲突，以及决定由哪一台微处理器控制总线的问题，I2C总线允许连接不同传送速率的设备。多台设备之间时钟信号的同步过程称为同步化。

在I2C总线传输过程中，将两种特定的情况定义为开始和停止条件（见图3）：当SCL保持“高”时，SDA由“高”变为“低”为开始条件；当SCL保持“高”且SDA由“低”变为“高”时为停止条件。开始和停止条件均由主控制器产生。使用硬件接口可以很容易地检测到开始和停止条件，没有这种接口的微机必须以每时钟周期至少两次对SDA取样，以检测这种变化。 　　SDA线上的数据在时钟“高”期间必须是稳定的，只有当SCL线上的时钟信号为低时，数据线上的“高”或“低”状态才可以改变。输出到SDA线上的每个字节必须是8位，每次传输的字节不受限制，但每个字节必须要有一个应答ACK。如果一接收器件在完成其他功能（如一内部中断）前不能接收另一数据的完整字节时，它可以保持时钟线SCL为低，以促使发送器进入等待状态；当接收器准备好接受数据的其它字节并释放时钟SCL后，数据传输继续进行。

USB
USB的硬件结构
　　USB采用四线电缆，其中两根是用来传送数据的串行通道，另两根为下游（Downstream)设备提供电源，对于高速且需要高带宽的外设，USB以全速12Mbps的传输数据；对于低速外设，USB则以1.5Mbps的传输速率来传输数据。USB总线会根据外设情况在两种传输模式中自动地动态转换。USB是基于令牌的总线。类似于令牌环网络或FDDI基于令牌的总线。USB主控制器广播令牌，总线上设备检测令牌中的地址是否与自身相符，通过接收或发送数据给主机来响应。USB通过支持悬挂/恢复操作来管理USB总线电源。USB系统采用级联星型拓扑，该拓扑由三个基本部分组成：主机（Host)，集线器（Hub)和功能设备。 　　主机，也称为根，根结或根Hub，它做在主板上或作为适配卡安装在计算机上，主机包含有主控制器和根集线器（Root Hub)，控制着USB总线上的数据和控制信息的流动，每个USB系统只能有一个根集线器，它连接在主控制器上。 　　集线器是USB结构中的特定成分，它提供叫做端口（Port)的点将设备连接到USB总线上，同时检测连接在总线上的设备，并为这些设备提供电源管理，负责总线的故障检测和恢复。集线可为总线提供能源，亦可为自身提供能源（从外部得到电源），自身提供能源的设备可插入总线提供能源的集线器中，但总线提供能源的设备不能插入自身提供能源的集线器或支持超过四个的下游端口中，如总线提供能源设备的需要超过100mA电源时，不能同总线提供电源的集线器连接。 　　功能设备通过端口与总线连接。USB同时可做Hub使用。

功能（主机）              功能（设备） 

1 VBUS (4.75－5.25 V) V    BUS (4.4－5.25 V) 
2 D-                       D- 
3 D+                       D+ 
4 接地                     接地 
　　USB 信号使用分别标记为 D+ 和 D- 的双绞线传输，它们各自使用 半双工的差分信号 并协同工作，以抵消长导线的电磁干扰。

LCD 
如果LCD使用的是VGA的信号，中间需要CPLD做转换

AC97 标准规格
　采用双芯片的PC声音解决方案； 　　两种标准的封装方式：48针和64针； 　　数字/模拟信号分离，全面改善信噪比（90db）； 　　16位立体声全双工codec、固定48K采样频率； 　　4种模拟立体声输入（分别来自LINE、CD、VIDEO、AUX）； 　　两种模拟单声道输入（分别来自麦克风和PC喇叭）； 　　可从两个外接音源交换的单声道麦克风进行输入； 　　高品质的CD输入； 　　立体声线性输出； 　　电话单声道输出； 　　支持电源管理 ； 　　可选音调控制； 　　可选高音控制； 　　可选3D立体声增强； 　　可选立体声耳机输出； 　　可选18或20位DAC及ADC分辩； 　　可选MODEM线性codec（ADC和DAC）； 　　可为麦克风选择第三个ADC输入通道。 　　根据AC97标准的规定，由于IC电路集成度较高，将DAC、ADC及其它相关的数字电路集成成为芯片形式后，不仅能够减少整个系统的设计成本，同时也可以获得更好、更有效的声音效果。这一点完全可以从其信噪比至少要求90db可以看出。此外，由于采用了双芯片的设计形式，厂商们在设计方面也可以更加灵活，更易于在整个系统中的集成。